/**
 * @file EditorLayoutManager.cpp
 * @brief Implementation of the advanced layout management system for Spark Engine Editor
 * @author Spark Engine Team
 * @date 2025
 */

#include "EditorLayoutManager.h"
#include "../Docking/SparkDockingSystem.h"  // For DockPosition enum
#include "EditorLogger.h"                    // For logging macros
#include <fstream>
#include <sstream>
#include <regex>
#include <filesystem>

namespace SparkEditor {

EditorLayoutManager::EditorLayoutManager() {
    EDITOR_LOG_DEBUG(LogCategory::UI, "EditorLayoutManager constructed");
}

EditorLayoutManager::~EditorLayoutManager() {
    Shutdown();
}

bool EditorLayoutManager::Initialize(const std::string& layoutDirectory) {
    if (m_isInitialized) {
        return true;
    }
    
    m_layoutDirectory = layoutDirectory;
    
    // Create layout directory if it doesn't exist
    std::filesystem::create_directories(layoutDirectory);
    
    // Create predefined layouts
    CreatePredefinedLayouts();
    
    // Load custom layouts from disk
    try {
        for (const auto& entry : std::filesystem::directory_iterator(layoutDirectory)) {
            if (entry.is_regular_file() && entry.path().extension() == ".layout") {
                try {
                    auto layout = LoadLayoutFromFile(entry.path().string());
                    if (!layout.name.empty()) {
                        m_layouts[layout.name] = layout;
                        EDITOR_LOG_DEBUG_F(LogCategory::UI, "Loaded custom layout: %s", layout.name.c_str());
                    }
                } catch (const std::exception& e) {
                    EDITOR_LOG_ERROR_F(LogCategory::UI, "Failed to load layout %s: %s", 
                                      entry.path().filename().string().c_str(), e.what());
                }
            }
        }
    } catch (const std::exception& e) {
        EDITOR_LOG_WARNING_F(LogCategory::UI, "Error scanning layout directory: %s", e.what());
    }
    
    // Apply default layout
    ApplyLayout("Spark Default");
    
    m_isInitialized = true;
    EDITOR_LOG_INFO(LogCategory::UI, "EditorLayoutManager initialized successfully");
    
    return true;
}

void EditorLayoutManager::Shutdown() {
    if (!m_isInitialized) {
        return;
    }
    
    // Save current layout if auto-save is enabled
    if (m_autoSaveEnabled && m_layoutChanged) {
        SaveCurrentLayout("LastSession", "Automatically saved on shutdown");
    }
    
    m_layouts.clear();
    m_panels.clear();
    m_isInitialized = false;
    
    EDITOR_LOG_INFO(LogCategory::UI, "EditorLayoutManager shut down");
}

void EditorLayoutManager::Update(float deltaTime) {
    if (!m_isInitialized) {
        return;
    }
    
    // Update auto-save timer
    if (m_autoSaveEnabled && m_layoutChanged) {
        m_autoSaveTimer += deltaTime;
        if (m_autoSaveTimer >= m_autoSaveInterval) {
            SaveCurrentLayout("AutoSave", "Automatically saved layout");
            m_autoSaveTimer = 0.0f;
            m_layoutChanged = false;
        }
    }
    
    // Update statistics
    UpdateLayoutStats();
}

void EditorLayoutManager::BeginFrame() {
    if (!m_isInitialized) {
        return;
    }
    
    // For now, we'll implement a simpler layout system without advanced docking
    // This can be enhanced when a newer ImGui version with docking is available
}

void EditorLayoutManager::EndFrame() {
    if (!m_isInitialized) {
        return;
    }
    
    // End frame processing
}

bool EditorLayoutManager::ApplyLayout(const std::string& layoutName) {
    auto it = m_layouts.find(layoutName);
    if (it == m_layouts.end()) {
        EDITOR_LOG_WARNING_F(LogCategory::UI, "Layout '%s' not found", layoutName.c_str());
        return false;
    }
    
    const auto& layout = it->second;
    
    // Update panel configurations
    for (const auto& [panelName, panelConfig] : layout.panels) {
        if (m_panels.find(panelName) != m_panels.end()) {
            m_panels[panelName] = panelConfig;
        }
    }
    
    // Mark for re-docking on next frame
    m_firstFrame = true;
    m_currentLayoutName = layoutName;
    m_lastLayoutSwitchTime = std::chrono::steady_clock::now();
    
    // Update usage statistics
    m_layoutUsageCount[layoutName]++;
    
    // Trigger layout change event
    LayoutChangeEvent event;
    event.type = LayoutChangeEvent::LayoutLoaded;
    event.layoutName = layoutName;
    OnLayoutChanged(event);
    
    EDITOR_LOG_INFO_F(LogCategory::UI, "Applied layout: %s", layoutName.c_str());
    return true;
}

bool EditorLayoutManager::SaveCurrentLayout(const std::string& layoutName, const std::string& description) {
    LayoutConfig layout = CaptureCurrentLayout();
    layout.name = layoutName;
    layout.displayName = layoutName;
    layout.description = description;
    layout.isBuiltIn = false;
    
    // Save to memory
    m_layouts[layoutName] = layout;
    
    // Save to disk
    std::string filePath = m_layoutDirectory + "/" + layoutName + ".layout";
    layout.filePath = filePath;
    
    if (SaveLayoutToFile(layout, filePath)) {
        LayoutChangeEvent event;
        event.type = LayoutChangeEvent::LayoutSaved;
        event.layoutName = layoutName;
        OnLayoutChanged(event);
        
        EDITOR_LOG_INFO_F(LogCategory::UI, "Saved layout: %s to %s", layoutName.c_str(), filePath.c_str());
        return true;
    }
    
    EDITOR_LOG_ERROR_F(LogCategory::UI, "Failed to save layout: %s", layoutName.c_str());
    return false;
}

bool EditorLayoutManager::LoadLayout(const std::string& layoutName) {
    return ApplyLayout(layoutName);
}

bool EditorLayoutManager::DeleteLayout(const std::string& layoutName) {
    auto it = m_layouts.find(layoutName);
    if (it == m_layouts.end()) {
        return false;
    }
    
    // Don't delete built-in layouts
    if (it->second.isBuiltIn) {
        EDITOR_LOG_WARNING_F(LogCategory::UI, "Cannot delete built-in layout: %s", layoutName.c_str());
        return false;
    }
    
    // Delete file if it exists
    if (!it->second.filePath.empty() && std::filesystem::exists(it->second.filePath)) {
        std::filesystem::remove(it->second.filePath);
    }
    
    // Remove from memory
    m_layouts.erase(it);
    
    EDITOR_LOG_INFO_F(LogCategory::UI, "Deleted layout: %s", layoutName.c_str());
    return true;
}

std::vector<LayoutConfig> EditorLayoutManager::GetAvailableLayouts() const {
    std::vector<LayoutConfig> layouts;
    layouts.reserve(m_layouts.size());
    
    for (const auto& [name, layout] : m_layouts) {
        layouts.push_back(layout);
    }
    
    // Sort: built-in layouts first, then custom layouts alphabetically
    std::sort(layouts.begin(), layouts.end(), [](const LayoutConfig& a, const LayoutConfig& b) {
        if (a.isBuiltIn != b.isBuiltIn) {
            return a.isBuiltIn; // Built-in first
        }
        return a.displayName < b.displayName; // Alphabetical
    });
    
    return layouts;
}

void EditorLayoutManager::RegisterPanel(const PanelConfig& config) {
    m_panels[config.name] = config;
    EDITOR_LOG_DEBUG_F(LogCategory::UI, "Registered panel: %s", config.name.c_str());
}

void EditorLayoutManager::UnregisterPanel(const std::string& panelName) {
    m_panels.erase(panelName);
    EDITOR_LOG_DEBUG_F(LogCategory::UI, "Unregistered panel: %s", panelName.c_str());
}

const PanelConfig* EditorLayoutManager::GetPanelConfig(const std::string& panelName) const {
    auto it = m_panels.find(panelName);
    return (it != m_panels.end()) ? &it->second : nullptr;
}

void EditorLayoutManager::UpdatePanelConfig(const std::string& panelName, const PanelConfig& config) {
    auto it = m_panels.find(panelName);
    if (it != m_panels.end()) {
        it->second = config;
        m_layoutChanged = true;
        
        LayoutChangeEvent event;
        event.type = LayoutChangeEvent::PanelMoved;
        event.panelName = panelName;
        OnLayoutChanged(event);
    }
}

void EditorLayoutManager::SetPanelVisible(const std::string& panelName, bool visible) {
    auto it = m_panels.find(panelName);
    if (it != m_panels.end() && it->second.isVisible != visible) {
        it->second.isVisible = visible;
        m_layoutChanged = true;
        
        LayoutChangeEvent event;
        event.type = visible ? LayoutChangeEvent::PanelOpened : LayoutChangeEvent::PanelClosed;
        event.panelName = panelName;
        OnLayoutChanged(event);
    }
}

bool EditorLayoutManager::IsPanelVisible(const std::string& panelName) const {
    auto it = m_panels.find(panelName);
    return (it != m_panels.end()) ? it->second.isVisible : false;
}

void EditorLayoutManager::SetPanelFloating(const std::string& panelName, bool floating) {
    auto it = m_panels.find(panelName);
    if (it != m_panels.end()) {
        it->second.isFloating = floating;
        m_layoutChanged = true;
    }
}

bool EditorLayoutManager::BeginPanel(const std::string& panelName) {
    auto it = m_panels.find(panelName);
    if (it == m_panels.end() || !it->second.isVisible) {
        return false;
    }
    
    const auto& config = it->second;
    
    ImGuiWindowFlags flags = 0;
    if (!config.canClose) {
        flags |= ImGuiWindowFlags_NoCollapse;
    }
    
    bool open = config.isVisible;
    bool began = ImGui::Begin(config.displayName.c_str(), config.canClose ? &open : nullptr, flags);
    
    // Update visibility if panel was closed
    if (config.canClose && !open && config.isVisible) {
        SetPanelVisible(panelName, false);
    }
    
    return began;
}

void EditorLayoutManager::EndPanel() {
    ImGui::End();
}

void EditorLayoutManager::ResetToDefault() {
    ApplyLayout("Spark Default");
    EDITOR_LOG_INFO(LogCategory::UI, "Reset to default layout");
}

void EditorLayoutManager::SetLayoutChangeCallback(std::function<void(const LayoutChangeEvent&)> callback) {
    m_layoutChangeCallback = callback;
}

void EditorLayoutManager::SetAutoSave(bool enabled, float interval) {
    m_autoSaveEnabled = enabled;
    m_autoSaveInterval = interval;
    m_autoSaveTimer = 0.0f;
    
    EDITOR_LOG_INFO_F(LogCategory::UI, "Auto-save %s with interval %.1fs", 
                     enabled ? "enabled" : "disabled", interval);
}

void EditorLayoutManager::CreatePredefinedLayouts() {
    // Create all predefined layouts
    m_layouts["Spark Default"] = CreateSparkDefaultLayout();
    m_layouts["Engine Debug"] = CreateEngineDebugLayout();
    m_layouts["Performance"] = CreatePerformanceLayout();
    m_layouts["Asset Creation"] = CreateAssetCreationLayout();
    m_layouts["Lighting Design"] = CreateLightingDesignLayout();
    m_layouts["Animation"] = CreateAnimationLayout();
    
    EDITOR_LOG_INFO(LogCategory::UI, "Created predefined layouts");
}

LayoutConfig EditorLayoutManager::CreateSparkDefaultLayout() {
    LayoutConfig layout;
    layout.name = "Spark Default";
    layout.displayName = "? Spark Default";
    layout.description = "Default Spark Engine Editor layout optimized for general game development";
    layout.isBuiltIn = true;
    
    // Scene Graph (left side, top)
    PanelConfig sceneGraph;
    sceneGraph.name = "SceneGraph";
    sceneGraph.displayName = "?? Scene Graph";
    sceneGraph.dockPosition = DockPosition::Left;
    sceneGraph.size = {300, 400};
    sceneGraph.dockRatio = 0.25f;
    sceneGraph.isVisible = true;
    sceneGraph.tabOrder = 0;
    layout.panels[sceneGraph.name] = sceneGraph;
    
    // Asset Explorer (left side, bottom)
    PanelConfig assetExplorer;
    assetExplorer.name = "AssetExplorer";
    assetExplorer.displayName = "?? Asset Explorer";
    assetExplorer.dockPosition = DockPosition::Left;
    assetExplorer.size = {300, 400};
    assetExplorer.dockRatio = 0.5f;
    assetExplorer.isVisible = true;
    assetExplorer.tabOrder = 1;
    assetExplorer.parentDock = "SceneGraph";
    layout.panels[assetExplorer.name] = assetExplorer;
    
    // Entity Inspector (right side)
    PanelConfig entityInspector;
    entityInspector.name = "EntityInspector";
    entityInspector.displayName = "?? Entity Inspector";
    entityInspector.dockPosition = DockPosition::Right;
    entityInspector.size = {350, 600};
    entityInspector.dockRatio = 0.25f;
    entityInspector.isVisible = true;
    layout.panels[entityInspector.name] = entityInspector;
    
    // 3D Viewport (center, top)
    PanelConfig viewport3D;
    viewport3D.name = "Viewport3D";
    viewport3D.displayName = "?? 3D Viewport";
    viewport3D.dockPosition = DockPosition::Center;
    viewport3D.size = {800, 500};
    viewport3D.dockRatio = 0.7f;
    viewport3D.isVisible = true;
    layout.panels[viewport3D.name] = viewport3D;
    
    // Game Preview (center, as tab with 3D Viewport)
    PanelConfig gamePreview;
    gamePreview.name = "GamePreview";
    gamePreview.displayName = "?? Game Preview";
    gamePreview.dockPosition = DockPosition::Center;
    gamePreview.size = {800, 500};
    gamePreview.isVisible = true;
    gamePreview.tabOrder = 1;
    gamePreview.parentDock = "Viewport3D";
    layout.panels[gamePreview.name] = gamePreview;
    
    // Engine Console (bottom)
    PanelConfig engineConsole;
    engineConsole.name = "EngineConsole";
    engineConsole.displayName = "??? Engine Console";
    engineConsole.dockPosition = DockPosition::Bottom;
    engineConsole.size = {1200, 200};
    engineConsole.dockRatio = 0.2f;
    engineConsole.isVisible = true;
    layout.panels[engineConsole.name] = engineConsole;
    
    return layout;
}

LayoutConfig EditorLayoutManager::CreateEngineDebugLayout() {
    LayoutConfig layout;
    layout.name = "Engine Debug";
    layout.displayName = "?? Engine Debug";
    layout.description = "Layout optimized for engine debugging and development";
    layout.isBuiltIn = true;
    
    // Performance Profiler (left side, top)
    PanelConfig profiler;
    profiler.name = "PerformanceProfiler";
    profiler.displayName = "?? Performance Profiler";
    profiler.dockPosition = DockPosition::Left;
    profiler.size = {400, 300};
    profiler.dockRatio = 0.3f;
    profiler.isVisible = true;
    layout.panels[profiler.name] = profiler;
    
    // Engine Console (left side, bottom)
    PanelConfig console;
    console.name = "EngineConsole";
    console.displayName = "??? Engine Console";
    console.dockPosition = DockPosition::Left;
    console.size = {400, 300};
    console.dockRatio = 0.5f;
    console.isVisible = true;
    console.tabOrder = 1;
    console.parentDock = "PerformanceProfiler";
    layout.panels[console.name] = console;
    
    // 3D Viewport (center)
    PanelConfig viewport;
    viewport.name = "Viewport3D";
    viewport.displayName = "?? 3D Viewport";
    viewport.dockPosition = DockPosition::Center;
    viewport.size = {800, 600};
    viewport.isVisible = true;
    layout.panels[viewport.name] = viewport;
    
    // Entity Inspector (right side, top)
    PanelConfig inspector;
    inspector.name = "EntityInspector";
    inspector.displayName = "?? Entity Inspector";
    inspector.dockPosition = DockPosition::Right;
    inspector.size = {350, 400};
    inspector.dockRatio = 0.25f;
    inspector.isVisible = true;
    layout.panels[inspector.name] = inspector;
    
    // Scene Graph (right side, bottom)
    PanelConfig sceneGraph;
    sceneGraph.name = "SceneGraph";
    sceneGraph.displayName = "?? Scene Graph";
    sceneGraph.dockPosition = DockPosition::Right;
    sceneGraph.size = {350, 300};
    sceneGraph.dockRatio = 0.4f;
    sceneGraph.isVisible = true;
    sceneGraph.tabOrder = 1;
    sceneGraph.parentDock = "EntityInspector";
    layout.panels[sceneGraph.name] = sceneGraph;
    
    return layout;
}

LayoutConfig EditorLayoutManager::CreatePerformanceLayout() {
    LayoutConfig layout;
    layout.name = "Performance";
    layout.displayName = "? Performance";
    layout.description = "Layout focused on performance analysis and optimization";
    layout.isBuiltIn = true;
    
    // Performance Profiler (top, large)
    PanelConfig profiler;
    profiler.name = "PerformanceProfiler";
    profiler.displayName = "?? Performance Profiler";
    profiler.dockPosition = DockPosition::Top;
    profiler.size = {1200, 300};
    profiler.dockRatio = 0.4f;
    profiler.isVisible = true;
    layout.panels[profiler.name] = profiler;
    
    // 3D Viewport (center)
    PanelConfig viewport;
    viewport.name = "Viewport3D";
    viewport.displayName = "?? 3D Viewport";
    viewport.dockPosition = DockPosition::Center;
    viewport.size = {800, 400};
    viewport.isVisible = true;
    layout.panels[viewport.name] = viewport;
    
    // Engine Console (bottom)
    PanelConfig console;
    console.name = "EngineConsole";
    console.displayName = "??? Engine Console";
    console.dockPosition = DockPosition::Bottom;
    console.size = {1200, 200};
    console.dockRatio = 0.25f;
    console.isVisible = true;
    layout.panels[console.name] = console;
    
    return layout;
}

LayoutConfig EditorLayoutManager::CreateAssetCreationLayout() {
    LayoutConfig layout;
    layout.name = "Asset Creation";
    layout.displayName = "?? Asset Creation";
    layout.description = "Layout optimized for asset creation and management";
    layout.isBuiltIn = true;
    
    // Asset Explorer (left side, large)
    PanelConfig assetExplorer;
    assetExplorer.name = "AssetExplorer";
    assetExplorer.displayName = "?? Asset Explorer";
    assetExplorer.dockPosition = DockPosition::Left;
    assetExplorer.size = {400, 600};
    assetExplorer.dockRatio = 0.3f;
    assetExplorer.isVisible = true;
    layout.panels[assetExplorer.name] = assetExplorer;
    
    // 3D Viewport (center, top)
    PanelConfig viewport;
    viewport.name = "Viewport3D";
    viewport.displayName = "?? 3D Viewport";
    viewport.dockPosition = DockPosition::Center;
    viewport.size = {600, 400};
    viewport.dockRatio = 0.6f;
    viewport.isVisible = true;
    layout.panels[viewport.name] = viewport;
    
    // Entity Inspector (right side)
    PanelConfig inspector;
    inspector.name = "EntityInspector";
    inspector.displayName = "?? Entity Inspector";
    inspector.dockPosition = DockPosition::Right;
    inspector.size = {350, 600};
    inspector.dockRatio = 0.25f;
    inspector.isVisible = true;
    layout.panels[inspector.name] = inspector;
    
    // Engine Console (bottom)
    PanelConfig console;
    console.name = "EngineConsole";
    console.displayName = "??? Engine Console";
    console.dockPosition = DockPosition::Bottom;
    console.size = {1000, 200};
    console.dockRatio = 0.3f;
    console.isVisible = true;
    layout.panels[console.name] = console;
    
    return layout;
}

LayoutConfig EditorLayoutManager::CreateLightingDesignLayout() {
    LayoutConfig layout;
    layout.name = "Lighting Design";
    layout.displayName = "?? Lighting Design";
    layout.description = "Layout specialized for lighting and environment design";
    layout.isBuiltIn = true;
    
    // Lighting Workspace (left side)
    PanelConfig lightingWorkspace;
    lightingWorkspace.name = "LightingWorkspace";
    lightingWorkspace.displayName = "?? Lighting Workspace";
    lightingWorkspace.dockPosition = DockPosition::Left;
    lightingWorkspace.size = {400, 700};
    lightingWorkspace.dockRatio = 0.3f;
    lightingWorkspace.isVisible = true;
    layout.panels[lightingWorkspace.name] = lightingWorkspace;
    
    // 3D Viewport (center, large)
    PanelConfig viewport;
    viewport.name = "Viewport3D";
    viewport.displayName = "?? 3D Viewport";
    viewport.dockPosition = DockPosition::Center;
    viewport.size = {800, 600};
    viewport.isVisible = true;
    layout.panels[viewport.name] = viewport;
    
    // Scene Graph (right side, top)
    PanelConfig sceneGraph;
    sceneGraph.name = "SceneGraph";
    sceneGraph.displayName = "?? Scene Graph";
    sceneGraph.dockPosition = DockPosition::Right;
    sceneGraph.size = {300, 350};
    sceneGraph.dockRatio = 0.22f;
    sceneGraph.isVisible = true;
    layout.panels[sceneGraph.name] = sceneGraph;
    
    // Entity Inspector (right side, bottom)
    PanelConfig inspector;
    inspector.name = "EntityInspector";
    inspector.displayName = "?? Entity Inspector";
    inspector.dockPosition = DockPosition::Right;
    inspector.size = {300, 350};
    inspector.dockRatio = 0.5f;
    inspector.isVisible = true;
    inspector.tabOrder = 1;
    inspector.parentDock = "SceneGraph";
    layout.panels[inspector.name] = inspector;
    
    // Engine Console (bottom)
    PanelConfig console;
    console.name = "EngineConsole";
    console.displayName = "??? Engine Console";
    console.dockPosition = DockPosition::Bottom;
    console.size = {1100, 150};
    console.dockRatio = 0.2f;
    console.isVisible = true;
    layout.panels[console.name] = console;
    
    return layout;
}

LayoutConfig EditorLayoutManager::CreateAnimationLayout() {
    LayoutConfig layout;
    layout.name = "Animation";
    layout.displayName = "?? Animation";
    layout.description = "Layout designed for animation and timeline editing";
    layout.isBuiltIn = true;
    
    // Scene Graph (left side, top)
    PanelConfig sceneGraph;
    sceneGraph.name = "SceneGraph";
    sceneGraph.displayName = "?? Scene Graph";
    sceneGraph.dockPosition = DockPosition::Left;
    sceneGraph.size = {300, 350};
    sceneGraph.dockRatio = 0.25f;
    sceneGraph.isVisible = true;
    layout.panels[sceneGraph.name] = sceneGraph;
    
    // Entity Inspector (left side, bottom)
    PanelConfig inspector;
    inspector.name = "EntityInspector";
    inspector.displayName = "?? Entity Inspector";
    inspector.dockPosition = DockPosition::Left;
    inspector.size = {300, 350};
    inspector.dockRatio = 0.5f;
    inspector.isVisible = true;
    inspector.tabOrder = 1;
    inspector.parentDock = "SceneGraph";
    layout.panels[inspector.name] = inspector;
    
    // 3D Viewport (center, top)
    PanelConfig viewport;
    viewport.name = "Viewport3D";
    viewport.displayName = "?? 3D Viewport";
    viewport.dockPosition = DockPosition::Center;
    viewport.size = {700, 400};
    viewport.dockRatio = 0.6f;
    viewport.isVisible = true;
    layout.panels[viewport.name] = viewport;
    
    // Game Preview (right side)
    PanelConfig gamePreview;
    gamePreview.name = "GamePreview";
    gamePreview.displayName = "?? Game Preview";
    gamePreview.dockPosition = DockPosition::Right;
    gamePreview.size = {400, 700};
    gamePreview.dockRatio = 0.3f;
    gamePreview.isVisible = true;
    layout.panels[gamePreview.name] = gamePreview;
    
    // Engine Console (bottom)
    PanelConfig console;
    console.name = "EngineConsole";
    console.displayName = "??? Engine Console";
    console.dockPosition = DockPosition::Bottom;
    console.size = {1000, 200};
    console.dockRatio = 0.25f;
    console.isVisible = true;
    layout.panels[console.name] = console;
    
    return layout;
}

void EditorLayoutManager::SetupDocking(const LayoutConfig& layout) {
    // Simplified docking setup without advanced ImGui docking features
    // For now, we'll manage panel positions manually
    EDITOR_LOG_DEBUG(LogCategory::UI, "Setting up layout (simplified): " + layout.name);
}

LayoutConfig EditorLayoutManager::CaptureCurrentLayout() {
    LayoutConfig layout;
    layout.name = "Current";
    layout.displayName = "Current Layout";
    layout.description = "Captured current layout state";
    layout.isBuiltIn = false;
    
    // Capture current panel states
    for (const auto& [panelName, panelConfig] : m_panels) {
        layout.panels[panelName] = panelConfig;
    }
    
    return layout;
}

bool EditorLayoutManager::SaveLayoutToFile(const LayoutConfig& layout, const std::string& filePath) {
    try {
        std::ofstream file(filePath);
        if (!file.is_open()) {
            return false;
        }
        
        // Simple JSON-like format
        file << "{\n";
        file << "  \"name\": \"" << layout.name << "\",\n";
        file << "  \"displayName\": \"" << layout.displayName << "\",\n";
        file << "  \"description\": \"" << layout.description << "\",\n";
        file << "  \"panels\": {\n";
        
        bool first = true;
        for (const auto& [panelName, panelConfig] : layout.panels) {
            if (!first) file << ",\n";
            first = false;
            
            file << "    \"" << panelName << "\": {\n";
            file << "      \"displayName\": \"" << panelConfig.displayName << "\",\n";
            file << "      \"dockPosition\": " << static_cast<int>(panelConfig.dockPosition) << ",\n";
            file << "      \"size\": [" << panelConfig.size.x << ", " << panelConfig.size.y << "],\n";
            file << "      \"position\": [" << panelConfig.position.x << ", " << panelConfig.position.y << "],\n";
            file << "      \"isVisible\": " << (panelConfig.isVisible ? "true" : "false") << ",\n";
            file << "      \"isFloating\": " << (panelConfig.isFloating ? "true" : "false") << ",\n";
            file << "      \"dockRatio\": " << panelConfig.dockRatio << ",\n";
            file << "      \"tabOrder\": " << panelConfig.tabOrder << "\n";
            file << "    }";
        }
        
        file << "\n  }\n";
        file << "}\n";
        
        return true;
    } catch (const std::exception& e) {
        EDITOR_LOG_ERROR_F(LogCategory::UI, "Failed to save layout file: %s", e.what());
        return false;
    }
}

LayoutConfig EditorLayoutManager::LoadLayoutFromFile(const std::string& filePath) {
    LayoutConfig layout;
    
    try {
        std::ifstream file(filePath);
        if (!file.is_open()) {
            return layout;
        }
        
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        
        // Very simple JSON parsing (replace with proper JSON library in production)
        std::regex nameRegex("\"name\"\\s*:\\s*\"([^\"]*)\"");
        std::regex displayNameRegex("\"displayName\"\\s*:\\s*\"([^\"]*)\"");
        std::regex descriptionRegex("\"description\"\\s*:\\s*\"([^\"]*)\"");
        
        std::smatch match;
        if (std::regex_search(content, match, nameRegex)) {
            layout.name = match[1].str();
        }
        if (std::regex_search(content, match, displayNameRegex)) {
            layout.displayName = match[1].str();
        }
        if (std::regex_search(content, match, descriptionRegex)) {
            layout.description = match[1].str();
        }
        
        layout.filePath = filePath;
        layout.isBuiltIn = false;
        
        // TODO: Parse panel configurations (simplified for now)
        
    } catch (const std::exception& e) {
        EDITOR_LOG_ERROR_F(LogCategory::UI, "Failed to load layout file: %s", e.what());
    }
    
    return layout;
}

bool EditorLayoutManager::ImportLayout(const std::string& filePath) {
    try {
        std::ifstream file(filePath);
        if (!file.is_open()) {
            return false;
        }
        
        std::string content((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
        file.close();
        
        // Simple JSON-like parsing without regex (simplified for now)
        LayoutConfig layout;
        layout.name = std::filesystem::path(filePath).stem().string();
        layout.displayName = layout.name;
        layout.description = "Imported layout";
        layout.filePath = filePath;
        layout.isBuiltIn = false;
        
        // For now, just create a basic layout
        // TODO: Implement proper JSON parsing without regex
        
        m_layouts[layout.name] = layout;
        return true;
        
    } catch (const std::exception& e) {
        EDITOR_LOG_ERROR_F(LogCategory::UI, "Failed to load layout file: %s", e.what());
        return false;
    }
}

void EditorLayoutManager::UpdateLayoutStats() {
    m_stats.totalPanels = static_cast<int>(m_panels.size());
    m_stats.visiblePanels = 0;
    m_stats.floatingPanels = 0;
    m_stats.dockedPanels = 0;
    
    for (const auto& [name, config] : m_panels) {
        if (config.isVisible) {
            m_stats.visiblePanels++;
            if (config.isFloating) {
                m_stats.floatingPanels++;
            } else {
                m_stats.dockedPanels++;
            }
        }
    }
    
    // Find most used layout
    if (!m_layoutUsageCount.empty()) {
        auto maxIt = std::max_element(m_layoutUsageCount.begin(), m_layoutUsageCount.end(),
            [](const auto& a, const auto& b) { return a.second < b.second; });
        m_stats.mostUsedLayout = maxIt->first;
    }
}

void EditorLayoutManager::OnLayoutChanged(const LayoutChangeEvent& event) {
    if (m_layoutChangeCallback) {
        m_layoutChangeCallback(event);
    }
}

EditorLayoutManager::LayoutStats EditorLayoutManager::GetLayoutStats() const {
    return m_stats;
}

} // namespace SparkEditor