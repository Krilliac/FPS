/**
 * @file ConsolePanel.cpp
 * @brief Implementation of the Console panel
 * @author Spark Engine Team
 * @date 2025
 */

#include "ConsolePanel.h"
#include <imgui.h>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>

namespace SparkEditor {

ConsolePanel::ConsolePanel() 
    : EditorPanel("Console", "console_panel") {
    // Initialize filter
    m_filter.showInfo = true;
    m_filter.showWarning = true;
    m_filter.showError = true;
}

ConsolePanel::~ConsolePanel() {
    // Destructor
}

bool ConsolePanel::Initialize() {
    std::cout << "Initializing Console panel\n";
    
    // Register built-in commands
    RegisterBuiltInCommands();
    
    // Add welcome message
    LogEntry welcomeEntry;
    welcomeEntry.level = LogLevel::INFO_;
    welcomeEntry.category = LogCategory::EDITOR;
    welcomeEntry.message = "Spark Engine Console initialized. Type 'help' for available commands.";
    welcomeEntry.timestamp = std::chrono::system_clock::now();
    AddLogEntry(welcomeEntry);
    
    return true;
}

void ConsolePanel::Update(float deltaTime) {
    ProcessPendingLogEntries();
    UpdateStats();
}

void ConsolePanel::Render() {
    if (!IsVisible()) return;

    if (BeginPanel()) {
        // Console toolbar
        if (ImGui::Button("Clear")) {
            Clear();
        }
        ImGui::SameLine();
        if (ImGui::Button("Export")) {
            ExportLog("console_log.txt");
        }
        ImGui::SameLine();
        ImGui::Checkbox("Auto-scroll", &m_scrollToBottom);
        ImGui::SameLine();
        ImGui::Checkbox("Show Filters", &m_showFilterControls);
        
        if (m_showFilterControls) {
            RenderFilterControls();
        }
        
        ImGui::Separator();
        
        // Log display area
        RenderLogDisplay();
        
        ImGui::Separator();
        
        // Command input area
        RenderCommandInput();
        
        // Context menu
        RenderContextMenu();
    }
    EndPanel();
}

void ConsolePanel::Shutdown() {
    std::cout << "Shutting down Console panel\n";
}

bool ConsolePanel::HandleEvent(const std::string& eventType, void* eventData) {
    return false;
}

void ConsolePanel::RegisterCommand(const ConsoleCommand& command) {
    m_commands[command.name] = command;
}

void ConsolePanel::UnregisterCommand(const std::string& commandName) {
    m_commands.erase(commandName);
}

std::string ConsolePanel::ExecuteCommand(const std::string& commandLine) {
    auto [command, args] = ParseCommandLine(commandLine);
    
    // Add to history
    ConsoleHistoryEntry historyEntry;
    historyEntry.command = commandLine;
    historyEntry.timestamp = std::chrono::system_clock::now();
    m_commandHistory.push_back(historyEntry);
    
    // Find and execute command
    auto it = m_commands.find(command);
    if (it != m_commands.end()) {
        try {
            std::string result = it->second.handler(args);
            m_commandCounter++;
            return result;
        } catch (const std::exception& e) {
            return "Command error: " + std::string(e.what());
        }
    }
    
    return "Unknown command: " + command + ". Type 'help' for available commands.";
}

void ConsolePanel::AddLogEntry(const LogEntry& entry) {
    std::lock_guard<std::mutex> lock(m_logMutex);
    
    m_logEntries.push_back(entry);
    
    // Limit log entries
    if (m_maxLogEntries > 0 && m_logEntries.size() > m_maxLogEntries) {
        m_logEntries.erase(m_logEntries.begin());
    }
    
    m_filterChanged = true;
    m_scrollToBottom = true;
}

void ConsolePanel::Clear() {
    std::lock_guard<std::mutex> lock(m_logMutex);
    m_logEntries.clear();
    m_filteredIndices.clear();
    m_filterChanged = true;
}

void ConsolePanel::SetFilter(const ConsoleFilter& filter) {
    m_filter = filter;
    m_filterChanged = true;
}

bool ConsolePanel::ExportLog(const std::string& filePath, const std::string& format) {
    // TODO: Implement log export
    std::cout << "Exporting log to: " << filePath << " (format: " << format << ")\n";
    return true;
}

ConsolePanel::ConsoleStats ConsolePanel::GetStats() const {
    std::lock_guard<std::mutex> lock(m_logMutex);
    return m_stats;
}

void ConsolePanel::RenderLogDisplay() {
    const float footer_height_to_reserve = ImGui::GetStyle().ItemSpacing.y + ImGui::GetFrameHeightWithSpacing();
    ImGui::BeginChild("ScrollingRegion", ImVec2(0, -footer_height_to_reserve), false, ImGuiWindowFlags_HorizontalScrollbar);
    
    if (m_filterChanged) {
        UpdateFilteredEntries();
    }
    
    // Render log entries
    ImGuiListClipper clipper;
    clipper.Begin(static_cast<int>(m_filteredIndices.size()));
    
    while (clipper.Step()) {
        for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++) {
            if (i < static_cast<int>(m_filteredIndices.size())) {
                size_t entryIndex = m_filteredIndices[i];
                if (entryIndex < m_logEntries.size()) {
                    RenderLogEntry(m_logEntries[entryIndex], entryIndex);
                }
            }
        }
    }
    
    if (m_scrollToBottom && ImGui::GetScrollY() >= ImGui::GetScrollMaxY()) {
        ImGui::SetScrollHereY(1.0f);
        m_scrollToBottom = false;
    }
    
    ImGui::EndChild();
}

void ConsolePanel::RenderCommandInput() {
    bool reclaimFocus = false;
    ImGuiInputTextFlags inputTextFlags = ImGuiInputTextFlags_EnterReturnsTrue | ImGuiInputTextFlags_CallbackHistory;
    
    if (ImGui::InputText("Command", m_commandBuffer, COMMAND_BUFFER_SIZE, inputTextFlags)) {
        std::string command = m_commandBuffer;
        if (!command.empty()) {
            // Add command to log
            LogEntry commandEntry;
            commandEntry.level = LogLevel::INFO_;
            commandEntry.category = LogCategory::CONSOLE;
            commandEntry.message = "> " + command;
            commandEntry.timestamp = std::chrono::system_clock::now();
            AddLogEntry(commandEntry);
            
            // Execute command
            std::string result = ExecuteCommand(command);
            
            // Add result to log
            LogEntry resultEntry;
            resultEntry.level = LogLevel::INFO_;
            resultEntry.category = LogCategory::CONSOLE;
            resultEntry.message = result;
            resultEntry.timestamp = std::chrono::system_clock::now();
            AddLogEntry(resultEntry);
        }
        
        m_commandBuffer[0] = '\0';
        reclaimFocus = true;
    }
    
    // Auto-focus on window apparition
    ImGui::SetItemDefaultFocus();
    if (reclaimFocus) {
        ImGui::SetKeyboardFocusHere(-1); // Auto focus previous widget
    }
}

void ConsolePanel::RenderFilterControls() {
    ImGui::Separator();
    
    // Log level filters
    ImGui::Text("Log Levels:");
    ImGui::SameLine();
    ImGui::Checkbox("Info", &m_filter.showInfo);
    ImGui::SameLine();
    ImGui::Checkbox("Warning", &m_filter.showWarning);
    ImGui::SameLine();
    ImGui::Checkbox("Error", &m_filter.showError);
    
    // Search filter
    static char searchBuffer[256] = "";
    ImGui::InputTextWithHint("Search", "Filter messages...", searchBuffer, sizeof(searchBuffer));
    
    if (strlen(searchBuffer) > 0) {
        m_filter.searchText = searchBuffer;
    } else {
        m_filter.searchText.clear();
    }
    
    m_filterChanged = true;
}

void ConsolePanel::RenderContextMenu() {
    if (m_showContextMenu) {
        ImGui::OpenPopup("ConsoleContextMenu");
        m_showContextMenu = false;
    }
    
    if (ImGui::BeginPopup("ConsoleContextMenu")) {
        if (ImGui::MenuItem("Copy")) {
            // TODO: Implement copy to clipboard
        }
        if (ImGui::MenuItem("Clear")) {
            Clear();
        }
        ImGui::Separator();
        if (ImGui::MenuItem("Export Log")) {
            ExportLog("console_export.txt");
        }
        ImGui::EndPopup();
    }
}

void ConsolePanel::RenderLogEntry(const LogEntry& entry, size_t index) {
    ImVec4 color = GetLogLevelColor(entry.level);
    
    // Timestamp
    std::string timestamp = FormatTimestamp(entry.timestamp);
    ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "[%s]", timestamp.c_str());
    ImGui::SameLine();
    
    // Level
    std::string levelStr;
    switch (entry.level) {
        case LogLevel::INFO_: levelStr = "INFO"; break;
        case LogLevel::WARNING_: levelStr = "WARN"; break;
        case LogLevel::ERROR_: levelStr = "ERROR"; break;
        default: levelStr = "UNKNOWN"; break;
    }
    ImGui::TextColored(color, "[%s]", levelStr.c_str());
    ImGui::SameLine();
    
    // Message
    ImGui::TextWrapped("%s", entry.message.c_str());
    
    // Context menu for individual entries
    if (ImGui::IsItemClicked(ImGuiMouseButton_Right)) {
        m_showContextMenu = true;
    }
}

void ConsolePanel::UpdateFilteredEntries() {
    m_filteredIndices.clear();
    
    for (size_t i = 0; i < m_logEntries.size(); ++i) {
        const LogEntry& entry = m_logEntries[i];
        
        // Level filter
        bool levelPass = false;
        switch (entry.level) {
            case LogLevel::INFO_: levelPass = m_filter.showInfo; break;
            case LogLevel::WARNING_: levelPass = m_filter.showWarning; break;
            case LogLevel::ERROR_: levelPass = m_filter.showError; break;
        }
        
        if (!levelPass) continue;
        
        // Search filter
        if (!m_filter.searchText.empty()) {
            std::string lowerMessage = entry.message;
            std::transform(lowerMessage.begin(), lowerMessage.end(), lowerMessage.begin(), ::tolower);
            std::string lowerSearch = m_filter.searchText;
            std::transform(lowerSearch.begin(), lowerSearch.end(), lowerSearch.begin(), ::tolower);
            
            if (lowerMessage.find(lowerSearch) == std::string::npos) {
                continue;
            }
        }
        
        m_filteredIndices.push_back(i);
    }
    
    m_filterChanged = false;
}

std::pair<std::string, std::vector<std::string>> ConsolePanel::ParseCommandLine(const std::string& commandLine) {
    std::istringstream iss(commandLine);
    std::vector<std::string> tokens;
    std::string token;
    
    while (iss >> token) {
        tokens.push_back(token);
    }
    
    if (tokens.empty()) {
        return {"", {}};
    }
    
    std::string command = tokens[0];
    std::vector<std::string> args(tokens.begin() + 1, tokens.end());
    
    return {command, args};
}

void ConsolePanel::RegisterBuiltInCommands() {
    // Help command
    ConsoleCommand helpCmd;
    helpCmd.name = "help";
    helpCmd.description = "Show available commands";
    helpCmd.usage = "help [command]";
    helpCmd.handler = [this](const std::vector<std::string>& args) -> std::string {
        std::stringstream ss;
        ss << "Available commands:\n";
        for (const auto& [name, cmd] : m_commands) {
            ss << "  " << name << " - " << cmd.description << "\n";
        }
        return ss.str();
    };
    RegisterCommand(helpCmd);
    
    // Clear command
    ConsoleCommand clearCmd;
    clearCmd.name = "clear";
    clearCmd.description = "Clear console log";
    clearCmd.usage = "clear";
    clearCmd.handler = [this](const std::vector<std::string>& args) -> std::string {
        Clear();
        return "Console cleared.";
    };
    RegisterCommand(clearCmd);
    
    // Echo command
    ConsoleCommand echoCmd;
    echoCmd.name = "echo";
    echoCmd.description = "Echo text to console";
    echoCmd.usage = "echo <text>";
    echoCmd.handler = [](const std::vector<std::string>& args) -> std::string {
        std::stringstream ss;
        for (size_t i = 0; i < args.size(); ++i) {
            if (i > 0) ss << " ";
            ss << args[i];
        }
        return ss.str();
    };
    RegisterCommand(echoCmd);
}

std::vector<std::string> ConsolePanel::GetCompletionSuggestions(const std::string& input) {
    std::vector<std::string> suggestions;
    
    for (const auto& [name, cmd] : m_commands) {
        if (name.find(input) == 0) {
            suggestions.push_back(name);
        }
    }
    
    return suggestions;
}

ImVec4 ConsolePanel::GetLogLevelColor(LogLevel level) const {
    switch (level) {
        case LogLevel::INFO_: return ImVec4(1.0f, 1.0f, 1.0f, 1.0f); // White
        case LogLevel::WARNING_: return ImVec4(1.0f, 1.0f, 0.0f, 1.0f); // Yellow
        case LogLevel::ERROR_: return ImVec4(1.0f, 0.0f, 0.0f, 1.0f); // Red
        default: return ImVec4(0.7f, 0.7f, 0.7f, 1.0f); // Gray
    }
}

std::string ConsolePanel::FormatTimestamp(const std::chrono::system_clock::time_point& timestamp) const {
    auto time_t = std::chrono::system_clock::to_time_t(timestamp);
    auto ms = std::chrono::duration_cast<std::chrono::milliseconds>(timestamp.time_since_epoch()) % 1000;
    
    std::stringstream ss;
    ss << std::put_time(std::localtime(&time_t), "%H:%M:%S");
    ss << "." << std::setfill('0') << std::setw(3) << ms.count();
    
    return ss.str();
}

void ConsolePanel::UpdateStats() {
    auto now = std::chrono::steady_clock::now();
    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - m_lastStatsUpdate);
    
    if (elapsed.count() >= 1) {
        std::lock_guard<std::mutex> lock(m_logMutex);
        
        m_stats.totalLogEntries = m_logEntries.size();
        m_stats.visibleLogEntries = m_filteredIndices.size();
        m_stats.commandsExecuted = m_commandCounter.load();
        
        // Count by level
        m_stats.entriesByLevel.clear();
        for (const auto& entry : m_logEntries) {
            m_stats.entriesByLevel[entry.level]++;
        }
        
        m_lastStatsUpdate = now;
    }
}

void ConsolePanel::ProcessPendingLogEntries() {
    // TODO: Process pending log entries from logger if integrated
}

} // namespace SparkEditor